# effective-java 3/e


## 객체 생성과 파괴
1/14 (목) - item 15~19

*핵심 요약 위주로 정리*

### 15. 클래스와 멤버의 접근 권한을 최소화하라

클래스의 맴버변수를 만들때 앤간하면 public 쓰지말고 딱 쓸곳에서만 접근되도록 엄격하게 제한 하라는 얘기

왠만하면 private 으로 맴버 변수로 선언하고 꼭 접근해야하는 클래스나 패키지가 있으면

package-private 으로 풀어줘라. 혹시 private 에서 자주 package-private 로 변경한다면 컴포넌트를

좀 더 잘게 분해하는건 아닌지 고려해봐야한다.

public 클래스의 인스턴스 필드는 되도록 public 이 아니어야 한다. public 은 스레드 세잎하지 않지.

public static 으로 상수를 쓸거면 final 꼭 붙히고 관례로 _ 를 잘 붙혀 쓰자.

public static final Thing[] = VALUES = { ... };

이렇게 생긴것도 결국 private static 으로 바꾸고 이거를 쓰고 싶으면 public static 메소드가 받아서

반환하는 식으로 변경해야한다.




### 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

```
// 이렇게 생긴 클래스 인스턴스들은 이 책 저자가 봤다면 오줌싼다.
Class Point {

    // 아래 public 은 private 으로, 접근하고 싶으면 public 메소드를 넣는다.
    public double x;
    public double y;

}
```


### 17. 변경 가능성을 최소화 하라

다른 언어들은 이제 val 같은걸 기본적으로 쓰는데 자바는 기본적으로 var 이다. 이런 환경에서

불변가능성을 최소화 하라니 개발자 참 피곤하게 한다. 불변이 되는 상태를 만들려면 이렇게 하자.

1. 객체 상태를 변경하는 메소드를 제공하지 않는다.
2. 클래스 확장 못하게 한다. (final class)
3. 모든 필드를 final 로 선언한다.
4. 모든 필드를 private 로 선언한다.
5. 자신 외에는 내부 가변 컴포넌트에 접근 못하게 한다.

이런걸 다 신경쓰면서 finalize 해야한다니 정신 똑바로 차려라.

하지만 이런걸 잘 해놓으면 기본적으로 스레드 세잎하다. 최초 생성후 변할일이 없으니 당연.

실패원자성도 마찬가지 얘기.

대신 값이 다르면 반드시 독립된 객체로 만들어야 하는데

값의 가지수가 많다면 이것들을 모두 만드는데 큰 비용을 쓰게된다.

이런 문제를 방지 하려면 다단계 연산을 하라고 하면서 BigInteger 를 예로 들고 있다.

다단계 연산속도를 높히기 위해 가변 동반클래스를 쓴다고 하는데, 사례가 막 와닿진 않는다.

String 과 StringBuilder 도 위 방식을 차용한 관계라고 한다.

가변인 객체를 String 으로 두고 builder 는 불변인 채 String 조립을 맡는 형태인거다.

일단 클래스는 왠만하면 불변으로 설계하자. 그리고 불변으로 못만들거 같으면 최대한 가변객체를 최소화 하자.

모든 필드는 private final 이어야 하고, 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야한다.

객체를 재활용할 목적으로 상태를 다시 초기화 하는 메소드는 만들지 말자. 무쓸모.


### 18. 상속보다는 컴포지션을 사용하라

클래스 상속은 일단 여기서 계속 강조하는 캡슐화를 위협한다.

상속하지 말고 컴포지션을 쓰라는데, 컴포지션이 뭐냐면

기존 클래스(수퍼 클래스에 해당)의 인스턴스를 참조하는 private 필드를 새로운 클래스(서브 클래스에 해당)에 둔다는 개념이다.

이런식

```
public class InstrumentedSet<E> extends ForwardingSet<E> {
    private int addCount = 0;

    public InstrumentedSet(Set<E> s) {
        super(s);
    }

    @Override public boolean add(E e) {
        addCount++;
        return super.add(e);
    }
    ...
}

```

ForwardingSet 클래스는 여기.
```
public class ForwardingSet<E> implements Set<E> {
    private final Set<E> s;
    public ForwardingSet(Set<E> s) { this.s = s; }

    public void clear() { s.clear(); }
    public boolean contains(Object o) { return s.contains(o); }
    ...

    public boolean add(E e) { return s.add(e); }
}
```

InstrumentedSet 은 HashSet 의 모든 기능을 정의한 Set 인터페이스를 활용해 설계되어 견고, 유연하단다.

Set 인터페이스를 구현하고 Set의 인스턴스를 인수로 받는 생성자를 하나 제공한다. 임의의 Set 에 계측 기능을 덧씌워

새로운 Set 으로 만드는것이다. InstrumentedSet 는 Set 을 래핑하는 느낌으로 짜기 때문에 래퍼 클래스라고 하고,

이런 식의 설계를 데코레이터 패턴이라고도 한다. 컴포지션과 전달의 조합은 넓은 의미로 위임(delegation) 이라고도 한다.

래퍼 클래스는 콜백에 문제가 있으므로, 객체 자신의 참조를 다른 객체에게 전달하는 콜백 프레임워크 에서의 사용은 부적합하다.

래퍼 객체에 포함된 객체는 자신의 래퍼 객체를 알지 못하므로 콜백을 할 경우 자신의 참조(this)만을 다른 객체에게 전달하기 때문이다.

(SELF 문제 라고도 한다)

상속은 강력하지만 캡슐화를 해친다. 상속은 상위클래스와 하위클래스가 순수한 is a 관계일때만 써야 한다. is-a 관계에서도

하위클래스의 패키지가 상위클래슥와 다르고 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제 될 수 있다.

래퍼 클래스 킹왕짱 컴포지션 사랑해요!!



### 19. 상속을 고려해 설계하고 문서화하라. 그러지 않다면 상속을 금지하라

전반적으로 이책은 가시성이나 캡슐화를 잘 지키는 것과 함께 전반적으로

잘 응집해 닫혀있으면서 확장엔 잘 열려있는 구조를 권장한다. 또한 가시성에서 나온 불변성을 꼭 지키라는것처럼

상속 또한 하위클래스가 어떤식으로 어떻게 구현될지 모르는 상황을 꺼려한다. 그래서 이 단원은 바로 요약을 하자면

상속을 위한 클래스를 설계하다 보면 그 클래스에 많은 제약이 생긴다. 이런건 주객이 전도된 상황이다.

서브 클래스를 안전하게 만들수 있도록 설계나 문서화를 확실히 할수 없다면 차차리 클래스의 상속을 금지하는 것이 좋은 방법이다.

금지하는 방법은 클래스를 final 로 선언하거나, 생성자를 private 혹은 default 로 두고 public static 팩토리 메소드를 추가하는것이다.

