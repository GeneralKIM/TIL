# effective-java 3/e


## 객체 생성과 파괴
1/14 (목) - item 15~20

*핵심 요약 위주로 정리*

### 15. 클래스와 멤버의 접근 권한을 최소화하라

클래스의 맴버변수를 만들때 앤간하면 public 쓰지말고 딱 쓸곳에서만 접근되도록 엄격하게 제한 하라는 얘기

왠만하면 private 으로 맴버 변수로 선언하고 꼭 접근해야하는 클래스나 패키지가 있으면

package-private 으로 풀어줘라. 혹시 private 에서 자주 package-private 로 변경한다면 컴포넌트를

좀 더 잘게 분해하는건 아닌지 고려해봐야한다.

public 클래스의 인스턴스 필드는 되도록 public 이 아니어야 한다. public 은 스레드 세잎하지 않지.

public static 으로 상수를 쓸거면 final 꼭 붙히고 관례로 _ 를 잘 붙혀 쓰자.

public static final Thing[] = VALUES = { ... };

이렇게 생긴것도 결국 private static 으로 바꾸고 이거를 쓰고 싶으면 public static 메소드가 받아서

반환하는 식으로 변경해야한다.




### 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

```
// 이렇게 생긴 클래스 인스턴스들은 이 책 저자가 봤다면 오줌싼다.
Class Point {

    // 아래 public 은 private 으로, 접근하고 싶으면 public 메소드를 넣는다.
    public double x;
    public double y;

}
```


### 17. 변경 가능성을 최소화 하라

다른 언어들은 이제 val 같은걸 기본적으로 쓰는데 자바는 기본적으로 var 이다. 이런 환경에서

불변가능성을 최소화 하라니 개발자 참 피곤하게 한다. 불변이 되는 상태를 만들려면 이렇게 하자.

1. 객체 상태를 변경하는 메소드를 제공하지 않는다.
2. 클래스 확장 못하게 한다. (final class)
3. 모든 필드를 final 로 선언한다.
4. 모든 필드를 private 로 선언한다.
5. 자신 외에는 내부 가변 컴포넌트에 접근 못하게 한다.

이런걸 다 신경쓰면서 finalize 해야한다니 정신 똑바로 차려라.

하지만 이런걸 잘 해놓으면 기본적으로 스레드 세잎하다. 최초 생성후 변할일이 없으니 당연.

실패원자성도 마찬가지 얘기.

대신 값이 다르면 반드시 독립된 객체로 만들어야 하는데

값의 가지수가 많다면 이것들을 모두 만드는데 큰 비용을 쓰게된다.

이런 문제를 방지 하려면 다단계 연산을 하라고 하면서 BigInteger 를 예로 들고 있다.

다단계 연산속도를 높히기 위해 가변 동반클래스를 쓴다고 하는데, 사례가 막 와닿진 않는다.

String 과 StringBuilder 도 위 방식을 차용한 관계라고 한다.

가변인 객체를 String 으로 두고 builder 는 불변인 채 String 조립을 맡는 형태인거다.

일단 클래스는 왠만하면 불변으로 설계하자. 그리고 불변으로 못만들거 같으면 최대한 가변객체를 최소화 하자.

모든 필드는 private final 이어야 하고, 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야한다.

객체를 재활용할 목적으로 상태를 다시 초기화 하는 메소드는 만들지 말자. 무쓸모.


### 18. 상속보다는 컴포지션을 사용하라

클래스 상속은 일단 여기서 계속 강조하는 캡슐화를 위협한다.

상속하지 말고 컴포지션을 쓰라는데, 컴포지션이 뭐냐면

기존 클래스(수퍼 클래스에 해당)의 인스턴스를 참조하는 private 필드를 새로운 클래스(서브 클래스에 해당)에 둔다는 개념이다.

왜 이래야 되냐면


### 19. 상속을 고려해 설계하고 문서화하라. 그러지 않다면 상속을 금지하라

### 20. 추상 클래스보다는 인터페이스를 우선하라
