# effective-java 3/e


## Java 8 관련 부분
1/28 (월) - item 21~24

### 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

자바 7까지는 현재의 인터페이스에 새로운 메소드가 추가될일이 없었음. 그래서 실제 인터페이스를 작성할때도

구현클래스가 어떻게 구현될지 딱히 생각하지 않고 디폴트 메소드가 삽입되었다.

자바 8에서는 핵심 컬랙션 인터페이스들에 람다를 위한 다수의 디폴트 메소드가 추가되었다.

디폴트 메소드들은 대부분 잘 동작하지만, 생각할 수 있는 모든 상황에서 불변식을 해치지 않는

디폴트 메서드를 작성하기 어렵다.

default 메소드 예
```
default boolean removeIf(Predicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean result = false;
    for (Iterator<E> it = iterator(); it.hasNext(); ) {
        if (filter.test(it.next()) {
            it.remove();
            result = true;
        }
    }
    return result;
}
```

인터페이스에 디폴트 메소드가 생긴건 좀 더 표준적인 메소드 구현을 위한 가이드 처럼 활용될 수도 있다.

디폴트 메소드는 기존 구현 메소드들과 어떻게 잘 어울러지고 연계될지는 잘 확인해보고 설계해야한다.

책에서는 다른 메소드들은 락을 염두한 구성이었는데 디폴트만 덩그러니 따라가지못하고 다른 방향으로 구현될 수 있다는 얘기이다.

사실 실수 하기 좋고, 구현체가 많거나 봐야할게 많으면 그런 연계성이 보장이 잘 안될 부분일거 같다;

인터페이스 원래 문제이기도 하지만 인터페이스를 수정하려면 기존에 구현된것과 충돌은 없는지 문제 없는지 잘 확인하고

인터페이스를 수정해야 한다. 나름의 구현 가이드같은건데 이 가이드가 변경되면 아래 구현들은 당연히 영향받는다.

그리고 인터페이스를 테스트할때는 구현테스트도 잘 하라고 하는데 이건 디폴트 메소드 유무와 관계없는 인터페이스 일반적인 얘기.


## 22. 인터페이스는 타입을 정의하는 용도로만 사용하라

인터페이스는 자신을 구현할 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다. 그러니까 나 가지고 어떤걸 구현해 라고 말해주는 용도.

그런데 이거에 맞지 않는 구성이 있는데 그것은 상수 인터페이스 - static final 만 줄줄이 있는 인터페이스를 말한다.

```
public interface PhysicalContstants {

    static final double AVOGADROS_NUMBER = 6.022_140_857e23;

    static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;

    ... 이런식으로 상수만 줄줄.
}
```

위 예는 상수 인터페이스는 인터페이스를 매우 잘못 쓴 케이스 이므로 쓰지 말자. 왜 그러냐면 구현체에게 이런 상수는 외부에서 구현해야할 대상이 아니므로

혼란을 야기할 뿐더러 내부 구현에 해당하는 이 상수에 의해 종속되어버릴 수 있다.

근데 이런 상수 인터페이스도 어쨌든 상수를 구현체 에게 제공하려고 하는건데 그게 목적이면 그냥 상수 유틸리티 클래스를 쓰면된다.


## 23. 태그 달린 클래스보다는 클래스 계층 구조를 활용하라

같은 클래스를 가지고 현재 표현하는 의미를 태그(enum 등으로) 값으로서 표현하는 클래스들이 있다.

그런 클래스들은 내부에 태그를 가지고 어떤 클래스인지 구별하면서 표현 해야해서 코드가 장황해지고 비효율적으로 구현된다.

```
class Figure {
    enum Shape { RECTANGLE, CIRCLE };

    final Shape shape;

    ...
    // 원, 사각형용 생성자 따로따로 있고

    // 이걸 메소드 내에서 일일히 구분해가면서 구현된다
    double area() {
        switch(shape) {
            case RECTANGLE:
                return length * width;
            case CIRCLE:
                return Math.PI * (radius * radius);
            default:
                throws ...;
        }
    }

}

```

자바에서는 서브타이핑을 제공하기때문에 위 형태와 같이 태그를 이용하여 구별하지 않는것이 좋다.

태크 달린 클래스를 계층구조로 바꾸는 방법

1. 계층구조의 루트가 될 추상 클래스 정의
2. 태그값에 따라 달라지는 메소드들을 루트 클래서 추상 메소드로 선언 (위 area가 같은것들말함)
3. 태그와 상관없이 동작이 일정한 메소드들을 루트 클래스 일반 메소드 추가
4. 모든 하위 클래스에서 공통으로 사용하는 데이터 필드들도 전부 루트로 올림
5. 그러고나면 루트 클래스에는 추상메서드인 area 만 남게됨


```
// 1.계층 구조의 루트가 될 추상 클래스 정의
abstract class Figure {

    //2. 태그값에 따라 달라지는 메소드들을 루트 클래서 추상 메소드로 선언 (위 area가 같은것들말함)
    abstract double area();
    5. 그러고나면 루트 클래스에는 추상메서드인 area 만 남게됨
}


//3. 태그와 상관없이 동작이 일정한 메소드들을 루트 클래스 일반 메소드 추가
//4. 모든 하위 클래스에서 공통으로 사용하는 데이터 필드들도 전부 루트로 올림

class Circle extends Figure {
    final double radius;

    //Circle 생성자 있을거고
    Circle(doucle radius) {this.radius = radius; }

    @Override double area() { return Math.PI * (radius * radius); }
}

class Rectangle extends Figure {
    final double length;
    final double width;

    //Rectangle 생성자 있을거고

    @Override doucle area() { return length * width; }
}

```

위 상황에서 태그방식이었을때 정사각형이 추가된다고 해보자 그럼 switch 에 태그 추가 생성자 추가 등등이 일어나겠지만, 계층구조일때는

아래와 같이 간단히 반영할 수 있다.
```
class Square extends Rectagle {
    Square(double side) {
        super(side, side);
    }
}
```

## 24. 멤버 클래스는 되도록 static 으로 만들라

이번 장은 중첩 클래스 얘기이다.

중첩클래스는 크게 4가지이고 각각 쓰임새가 다르다.

1. 정적 멤버 클래스
```
다른 클래스 안에 선언되고 바깥 클래스의 private 멤버에도 접근 가능한거 외엔 일반 클래스와 유사하다.
바깥 클래스와 함께 쓰일때만 유용한 public 도우미 클래스. 다른 정적 멤버와 똑같은 접근 규칙을 적용 받는다.
private 으로 선언하면 바깥 클래스에서만 적용된다.
```

2. (비정적) 멤버 클래스
```
static 이 앞에 붙음. 비정적 멤버 클래스와 바깥 클래스 인스턴스가 암묵적으로 연결되며 클래스명.this 형태로 참조 가능하다.
비정적 멤버와 바깥 인스턴스 관계는 멤버 클래스가 인스턴스화 될떄 확립되며 변경 불가하다. 이 관계정보는 비정적 멤버 클래스 인스턴스 안에 만들어져 메모리 차지+시간도 더 걸린다.
맴버 클래스에서 바깥 인스턴스에 접근할일이 없다면 무조건 static 을 붙혀 정적 맴버로 만들어라.
위에 설명한 참조 특성덕분에 이 참조를 저장할때 시간과 공간이 소비되며 심할경우 GC 가 수거하지 못하는 수가 있으므로 정적으로 만들어라.

```

3. 익명 클래스
```
이름 없는 클래스이면서 바깥 클래스의 멤버도 아니다. 코드 어디에서든 만들 수 있고 오직 비정적인 문맥에서
사용될때만 바깥 클래스의 인스턴스를 참조할수 있다. 이 구조는 람다에서 많이 쓴다.
```

4. 지역 클래스
```
이걸 써본기억이 거의 없는거 같은데, 지역변수를 선언할 수 있는 곳에다 선언될 수 있고 지역변수 처럼 돌아간다.
멤버 클래스 처럼 이름이 있고 반복 사용되고 익명 처럼 비정적 문맥에서 사용될때만 바깥 인스턴스 참조 할수 있다.
```

정적 멤버 클래스를 제외하고는 모두 inner class 이다.

보통 중첩클래스는 메소드 안이 너무 길어져 정의 하기 어려울때 맴버 클래스로 떼서 만든다.

멤버 클래스의 인스턴스 각가이 바깥 인스턴스를 참조한다면 비정적, 그렇지 않음 정적으로.

중첩클래스가 한 메소드에만 쓰이고 생성지점도 한군데라면 익명을 쓰자. 그게 아니면 지역 클래스로 써라.


